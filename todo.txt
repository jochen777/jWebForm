
 * - submit button (OK)
 * - simple input-element (OK)
 * - validate elements (OK)
 * - preset elements (OK)
 * - elements should expose a model (OK)
 *  check if complete form is valid (OK)
 * - Formvalidator (OK)
 * - tabindex(OK)
 * placeholder (OK)
 * - komplex input-form (OK)
  * set internal value (OK)
  * validate date (OK)
  * korrect validation-display for date (OK)
 
 * - xsrf (OK)
 
 * - firstRun? / * - form-id (mehrere forms pro Seite!. Entscheidung: edited=1 oder form-element-ids. (Symfony: form-element-ids - vielleicht diese optional machen - also nur einsetzen, wenn zwei Forms am start sind?) (OK)
 
 * Refactor and extend test (date, xsrf-protection) (OK)
 * idee: Die GetHTML Methode bekommt erst den Request und macht dann das nötige. nicht schon der Konstruktor. (OK)
 * Idee: ElementResult bekommt nicht html-string, sondern render-objekt (OK)
 
 * Everything immutable! (OK)
 * test 2 forms on the same page. (OK)
 * REFACTORINGS!! (RenderHints (OK), Decoration (OK))
 * fix form-result (OK)
 * could Element be immutable or the others too? (OK)
 * introduce HTMLProducer and avoid two loops over elements (OK)
 
 * never use null (OK)
 * introduce performance-tests (OK)
 * avoid Tabindex interface (OK)
 * Builder for ElementResult and theme just in Form (not in PrepareInfos) (OK)
 * run should not return html but a "HTMLRenderer" that renders the html in case we want it (OK)
  * - different themes: via: Each element has a hash of renderers. Hash has always "default", but can have more (bootstrap, mobile...) (OK)
 *   - you can add a set of renderers to a form to style differently (OK)
 * Provide clean values (LocalDate, boolean, integer...) (OK)
 -> Idee1: Return extended ElementResults with an extra field for the correct data
 -> Idee2: Versuche das End-API zu formulieren, vielleicht folgt dann das korrekt ergebnis
 -> element - nicht mehr immutable (** das ist wahrscheinlich am besten!)
 -> Ergebnis-Holder
 -> object in addition to value in ElementResult with cast
* 
 * fix form-result finally ( hat viel zu viele Elemente! -> Idee: jedes Element hat unveränderliche Werte (z.B. tabindexincr.) diese Gruppieren und als objekt zurückliefern) (OK)
 * Do we need Themeable Interface at all? Reicht es nicht, den Render-Key zurückzugeben? Und wenn beim Rendern ein Key gefunden wird, wird der HTMLRenderer im Theme verwendet. (OK)
 * decide if we need raw object in ElementResult. so instead of "String value" -> Object value; -> NO
 * More Form-Elements (
 Select (OK)
 , checkbox, (OK)
 Label (OK)
 html, (OK)
 hidden, (OK)
 textArea, (OK)
 Number, (OK)
 Passwort, (OK)
 radio, (OK)
 fileupload, (OK) 
 )
 * vernünftige code-formating regeln (OK)
 * decide if XXXElement or XXXInput or XXX and rename consistent (.net: Ohne, php: xxType, formchecker: Input) (OK)
 * Idee: Replace Element with Function<t,i> from java.util.function (OK)
 * test new elements
 * alle elemente mit vernünftigem Bootstrap-Theme ausgeben (OK)
 * Warning, wenn zweimal der gleiche Name eines Elements einem Form hinzugegügt wird. Exception!! (OK)
 * Führe valueData als Objekt im Result ein. (und elemeniere die Zugriffe auf das Element) (OK)
 * neue Exeption for double element (OK)
 * number testen (OK)
 * leere Namen korrekt abfangen, elemente können leere Namen haben. (OK)
* elements can have an empty name, if they don't have a representation! (OK) 
* get rid of extends in form-elements by introducing general oneElementStyle helper Class (OK)
* better abstraction in ThemeRenderer (OK)
* nur noch ein renderer für default. -> Theme bekommt den StandardRenderer als Hilfe. (OK)
* ElementRenderer noch einfacher machen und Bootstrap davon ableiten. -> Nein. Bootstrap IST default. OK
-> perhaps we should add an elementContainer to the form. The container holds the element, the behaviour and the validation (OK)
 * Idee: könnte validation unabhängig von den Elementen stattfinden? Die validation erfolgt dann nur auf dem Value. Dafür neues Objekt einführen: ValidatedElement<Element, Validtor> (OK) 
* ProducerInput soll Source und Validation und Behaviour bekommen. Also eigentlich ElementContainer (OK)
* ElementResult braucht noch source? (OK)
* Behaviour, dass "*" an das Label macht (OK)
* Automatische (*) bei Required feldern. (OK)
* globale Behaviours (OK)
 * Behaviour braucht auch die Validations (OK)
 * bahaviour should be interface (OK)
 * Behaviour sollte immer in Listenform ankommen. (OK)
* - maxLen (via request??) (OK)
* change method if fileupload is used (Element kann Flag-Interface implementieren. Wenn das gesetzt ist, wird die Methode geändert) (OK)
 * Achtung: Wenn man Eine Form abschickt (Submitted=true) ober nicht alle Felder übermittelt, kommt es zu NPE (OK)
 * In form and in Formresult: do we need Map<Element, ElementResult>? Or can we live with a List<ElementResult>? (NO, leave it like it is)
 * trim? (OK)
 * translations (OK)
 *  MAxlen, required muessen sich in inputfields wiederfinden (OK)
 * check, ob security-violations drin sind
 * select with groups (OK)
 * introduce more protected (OK)
* date-select with dropdowns (OK)
 * Fix test. Read file in a better way. (OK)
 * Make BootstrapRenderer element agnostic. Means: he should check which element to draw, and then decide to paint it differently. Maybe with marker-interfaces (OK)
 * make renderer smaller. (OK)
 * Make BootstrapRenderer more generic, so it can be easly subclassed. Include start/end as well. Get rid of startEndRenderer? (OK) 
 * move classes to right packages
 * implement a template, that renders the form (OK)
 * drop konzept of Theme.KEY entirely? (OK)
* try with mustache. (Idea: Map with booleans to check which element we have to render) (WORKS!!) :) (OK)
 * eliminate new, eliminate null (OK)
* make it JDK 9 ready (OK)
* erzwinge Request-Chain .cloneWithMaxLenInput(500).cloneWithNullCheck().cloneWithTrim() bzw. biete sinnvollen Default dafür an. (OK)
* fix checkbox (OK)
* fix filling of mustache templates (OK)
* form2bean as "integration" project (OK)
* fix moving dropdown-box on example form (WTF?!) (OK)
* fix nullpointer bei problem mit textDate (OK)
* convert SelectDate to new GroupElement (OK)
* Element und GroupElement müssen super-Typ haben. Davon können dann beide ableiten. (OK)
* introduce simpler groups: Idee: Jede FormElement Liste ist eine Gruppe und wird von WF rekursiv genau wie die erste Liste behandelt (OK)
* consider loosing the last dependency: Normally we use a template engine, that is doing the escaping... (OK)
* Decoration muss Teil vom Container werden! (OK)
* cleanup TextDate and SelectDate (OK)
* Todo: More tests for View (Method, fileupload, htmlvalidation) (OK)
* Introduce Builder for each element (jwebform.element.builder) with greatly simplified API (OK)
* Introduce FormBuilder for greatly simplyfied API (OK)
* formValidator soll keine Map bekommen, sondern ein neues Objekt (was eine Map enthält) (OK)
* MyFormBuilder sollte Static-Imports haben, damit Type.XXX entfallen kann. (OK)
* Enum for html5Validaiton in View (Remmber: no boolean arguments!) (OK)
* make StringUtils Package private (OK)
* Rebuild test-cases. Isolate upload case from other cases. Make tests smaller (OK)
* check if we can have less public
* clean up producerInfo. Dismiss redundandent View Objects (OK)
* Doku jWebForm: template.md (OK)
* Doku: build your own type (OK)
#############################

Namen wechseln:
* Type / Element
* Type

Bisher:
-------
Element
  SingleType  - GroupType

ElementContainer (Element, Validator, Decoration)

ElementResult

StaticElementInfo

Type
TypeBuilder

-----------
Besser:
Element
 SingleElement - GroupElement

BuildInElements
 ElementBuilder
-------------
Best:
FieldType
 SingleFieldType  - GroupFieldType

Field (container für FormFieldType, Criterias, Decoration)

FieldResult

StaticFieldInfo

BuildInField
FieldBuilder



(Suggestion: Fieldcontainer | Field | Decoration | Validator )
 is the container of a type, a validator and a decoration)

* Kein Validator mehr im Element sondern eine Liste von Criterias
* elment komplett loswerden.
* RFE und TODOS elemenieren
* Kommentare hinzufügen
* validatoinREsult muss methode bekommen, die die error-objekte zurückliefert.

----

Aufgefallen bei Integration in Produktion:
* Type ist zu generisch. Besser z.B. "FormType" / "Typebuilder". Idee: Typebuilder und Type in einer klasse

* best practice beschreiben: FormBuilder klasse sollte validierung, form darstellung und daten-handling machen.
Nicht mehr! Validierungs-Funktionen am besten per Lamda reinreichen.

* in pebble: dynamiccally include view elements (avoid long if/else)

harmonize styleguide filenames in example project (camelcase and asdf_msdf mixed)




* doku: build your own validator


* ElementContainer umbenennen in FormElement?
-> Django: Field, Symfony: Type, .net: type/nichts

* Simpler API for Theming


* Consider Arrays instead of Lists

* how can we avoid sublcassing only to have a new renderer? (vielleicht über Renderer-Interface?): 
				neues "Signature" Feld im FormResult einführen? Damit kann man die Ausgabe leichter steuern, ohne ständig ein neues Objejt zu benötigen
				-> besser: Signature in Decoration einfuehren!
* Integration: Google Captcha with praeProcessor: CheckCaptcha

* write test for integration project

maxlen required??
* View::DrawableElement - Inputs, die mit Marker interface markiert sind, können View-Infos zurückliefern. (Einfach eine Map, die dann mustache verwertet)

Ideen: Config Objekt mit wichtigsten Einstellungen: Theme, FormResultBuilder, Logger(!), Request....

Idee: Gib Logging-Lambda mit rein, um bestimmte sachen loggen zu können, z.B. debug-infos

* renderer: form_as_p, form_as_table, form_as_li

* Checkout django forms (https://docs.djangoproject.com/en/2.0/topics/forms/)
* Move to junit5 (class: ...Should - methods "return empty array if ..."

 
######################## V 0.1
 
* Speed-Optimierung: Wrap should work with StringBuilder
 * evtl. einen EmailType einführen? Wie ist die Browserkompatibiltät?
 * Idee: Methode, die ein Javascript ausgibt, die das Formular validiert
 * AttributeBuilder mit einfachem Builder: AttributeBuilder.build("class", "form-class", "required", ""...)
 
 * Kann StaticElementInfo auch als Eingabe für die Elemente verwendet werden?
 * evtl. staticElmentInfo mit Vererbungshierachie? 
 
 * google captcha in core with lamdas for json serialisierung/desserialsierung
 
 * html output generally over simple template engine?!
 
 
 * bean-validation
 * fromBean, toBean
 * Spring integration
 
 
## Nüsse:

* Tabindex (OK)
* Wie kann man einen Fehler setzen? (z.B. ein FormularValidtorar... PW) (OK)
* Wie kann Captcha den Submit-Button ädnern? -> Es braucht einen modifizierten Submit-Button dafür. Also etwa: CatpachSubmit()


* Wie kann man mit einer Zeile ein ganzes Theme ändern? (OK)
* Wie bekommt man _wrapper_ oder neuandordnungen hin?
* Wie kann das Themening im Template aussehen? 
* Wie kann ein FormularRenderer die Anordnung der Inputs beeinflussen? 
* translation
* wie bekommt man die values raus?

* Evtl. sind diese Behaviours interessant? https://ci.apache.org/projects/wicket/guide/6.x/guide/advanced.html


