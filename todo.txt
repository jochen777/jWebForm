 * - submit button (OK)
 * - simple input-element (OK)
 * - validate elements (OK)
 * - preset elements (OK)
 * - elements should expose a model (OK)
 *  check if complete form is valid (OK)
 * - Formvalidator (OK)
 * - tabindex(OK)
 * placeholder (OK)
 * - komplex input-form (OK)
  * set internal value (OK)
  * validate date (OK)
  * korrect validation-display for date (OK)
 
 * - xsrf (OK)
 
 * - firstRun? / * - form-id (mehrere forms pro Seite!. Entscheidung: edited=1 oder form-element-ids. (Symfony: form-element-ids - vielleicht diese optional machen - also nur einsetzen, wenn zwei Forms am start sind?) (OK)
 
 * Refactor and extend test (date, xsrf-protection) (OK)
 * idee: Die GetHTML Methode bekommt erst den Request und macht dann das nötige. nicht schon der Konstruktor. (OK)
 * Idee: ElementResult bekommt nicht html-string, sondern render-objekt (OK)
 
 * Everything immutable! (OK)
 * test 2 forms on the same page. (OK)
 * REFACTORINGS!! (RenderHints (OK), Decoration (OK))
 * fix form-result (OK)
 * could Element be immutable or the others too? (OK)
 * introduce HTMLProducer and avoid two loops over elements (OK)
 
 * never use null (OK)
 * introduce performance-tests (OK)
 * avoid Tabindex interface (OK)
 * Builder for ElementResult and theme just in Form (not in PrepareInfos) (OK)
 * run should not return html but a "HTMLRenderer" that renders the html in case we want it (OK)
  * - different themes: via: Each element has a hash of renderers. Hash has always "default", but can have more (bootstrap, mobile...) (OK)
 *   - you can add a set of renderers to a form to style differently (OK)
 * Provide clean values (LocalDate, boolean, integer...) (OK)
 -> Idee1: Return extended ElementResults with an extra field for the correct data
 -> Idee2: Versuche das End-API zu formulieren, vielleicht folgt dann das korrekt ergebnis
 -> element - nicht mehr immutable (** das ist wahrscheinlich am besten!)
 -> Ergebnis-Holder
 -> object in addition to value in ElementResult with cast
* 
 * fix form-result finally ( hat viel zu viele Elemente! -> Idee: jedes Element hat unveränderliche Werte (z.B. tabindexincr.) diese Gruppieren und als objekt zurückliefern) (OK)
 * Do we need Themeable Interface at all? Reicht es nicht, den Render-Key zurückzugeben? Und wenn beim Rendern ein Key gefunden wird, wird der HTMLRenderer im Theme verwendet. (OK)
 * decide if we need raw object in ElementResult. so instead of "String value" -> Object value; -> NO
 #############################
 
 
 
 
 * More Form-Elements (
 Select (OK)
 , checkbox, (OK)
 Label (OK)
 html, (OK)
 hidden, (OK)
 textArea, (OK)
 Number, (OK)
 Passwort, 
 radio, 
 fileupload, 
 )
 * vernünftige code-formating regeln
 * add new elements to test
 * decide if XXXElement or XXXInput or XXX and rename consistent
 * - maxLen (via request??)
 * form-id schon im request einbauen. dann brauchen die form-elemente das nicht mehr als eingabeparameter
 * select with groups
 * Behaviours (decorations to input-tag, decorations to label, decorations to help, decorations to error, decorations to all around)
 * check, ob security-violations drin sind
 * introduce more protected
 
 * Kann StaticElementInfo auch als Eingabe für die Elemente verwendet werden?
 * evtl. staticElmentInfo mit Vererbungshierachie? 
 * ausprobieren: Wie ist das Rendern im Template?

 
 * start with renderers (translation!)
 * implement a template, that renders the form
 
 * custom filters for request (max-len...)
 * bean-validation
 * fromBean, toBean
 * explorable api (form.addText, form.addTextArea
 * Spring integration
 * Warning, if non element is required. (This will not make sense!)
 
 
## Nüsse:

* Tabindex (OK)
* Wie kann man einen Fehler setzen? (z.B. ein FormularValidtorar... PW) (OK)
* Wie kann Captcha den Submit-Button ädnern? -> Es braucht einen modifizierten Submit-Button dafür. Also etwa: CatpachSubmit()


* Wie kann man mit einer Zeile ein ganzes Theme ändern? (OK)
* Wie bekommt man _wrapper_ oder neuandordnungen hin?
* Wie kann das Themening im Template aussehen? 
* Wie kann ein FormularRenderer die Anordnung der Inputs beeinflussen? 
* translation
* wie bekommt man die values raus?

* Evtl. sind diese Behaviours interessant? https://ci.apache.org/projects/wicket/guide/6.x/guide/advanced.html


 